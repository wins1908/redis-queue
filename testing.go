package redisq

import (
	"context"
	"time"

	"github.com/adjust/rmq"
	newrelic "github.com/newrelic/go-agent"
	"github.com/stretchr/testify/mock"
)

// MockAcknowledger is an autogenerated mock type for the MockAcknowledger type
type MockAcknowledger struct {
	mock.Mock
}

// Ack provides a mock function with given fields: ctx
func (_m *MockAcknowledger) Ack(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delay provides a mock function with given fields: ctx, d, delayedAt
func (_m *MockAcknowledger) Delay(ctx context.Context, d Delivery, delayedAt time.Time) error {
	ret := _m.Called(ctx, d, delayedAt)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Delivery, time.Time) error); ok {
		r0 = rf(ctx, d, delayedAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Push provides a mock function with given fields: ctx
func (_m *MockAcknowledger) Push(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Reject provides a mock function with given fields: ctx
func (_m *MockAcknowledger) Reject(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockConnection is an autogenerated mock type for the MockConnection type
type MockConnection struct {
	mock.Mock
}

// Name provides a mock function with given fields:
func (_m *MockConnection) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// OpenQueue provides a mock function with given fields: name
func (_m *MockConnection) OpenQueue(name string) rmq.Queue {
	ret := _m.Called(name)

	var r0 rmq.Queue
	if rf, ok := ret.Get(0).(func(string) rmq.Queue); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rmq.Queue)
		}
	}

	return r0
}

// Publisher provides a mock function with given fields:
func (_m *MockConnection) Publisher() Publisher {
	ret := _m.Called()

	var r0 Publisher
	if rf, ok := ret.Get(0).(func() Publisher); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Publisher)
		}
	}

	return r0
}

// MockConsumer is an autogenerated mock type for the MockConsumer type
type MockConsumer struct {
	mock.Mock
}

// Consume provides a mock function with given fields: ctx, d
func (_m *MockConsumer) Consume(ctx context.Context, d Delivery) error {
	ret := _m.Called(ctx, d)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Delivery) error); ok {
		r0 = rf(ctx, d)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Type provides a mock function with given fields:
func (_m *MockConsumer) Type() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type StubNewRelicDataStoreConfig struct {
	StubHost         string
	StubPortPathOrID string
	StubProduct      newrelic.DatastoreProduct
}

func (s *StubNewRelicDataStoreConfig) Host() string                       { return s.StubHost }
func (s *StubNewRelicDataStoreConfig) PortPathOrID() string               { return s.StubPortPathOrID }
func (s *StubNewRelicDataStoreConfig) Product() newrelic.DatastoreProduct { return s.StubProduct }

// MockPublisher is an autogenerated mock type for the MockPublisher type
type MockPublisher struct {
	mock.Mock
}

// Publish provides a mock function with given fields: ctx, pub
func (_m *MockPublisher) Publish(ctx context.Context, pub Publishing) error {
	ret := _m.Called(ctx, pub)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Publishing) error); ok {
		r0 = rf(ctx, pub)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
